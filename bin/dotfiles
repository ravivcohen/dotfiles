#!/bin/bash


echo 'Dotfiles - Raviv Cohen'


for var in "$@"
do
    if [[ "$var" == "-h" || "$var" == "--help" ]]; then cat <<HELP
      Usage: $(basename "$0") [-f | -h]

      -h / --help run help
      -f / --force-reinstall force to re-run and re-install all dotfiles
      -s / --skip-update force skip updating or checking status of dotfiles

      See the README for documentation.
      https://github.com/ravivcohen/dotfiles
HELP
exit

  elif [[ "$var" == "-f" || "$var" == "--force-reinstall" ]]; then
    export new_dotfiles_install=1

  elif [[ "$var" == "-s" || "$var" == "--skip-update" ]]; then
    export skip_update=1
  fi

done

#Setup the DOTFILES_HOME variable to be the current users home.
#This is needed when running something as STD user.
export DOTFILES_HOME=$HOME

#
if [[ ! -d ~/.dotfiles ]]; then
  export lib_file=/tmp/lib_file$$.$RANDOM
  curl -fsSL https://raw.githubusercontent.com/ravivcohen/dotfiles/master/libs/helper_functions.sh -o $lib_file
else
  export lib_file=$HOME/.dotfiles/libs/helper_functions.sh
fi

#All Helper functions can now be found inside libs/helper_functions.
. $lib_file

## TODO: Move this into a get_os functions that is smart return var right away if already set
# OSX
if [[ "$OSTYPE" =~ ^darwin ]]; then
  export OS="osx" 
# Ubuntu.
elif [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]]; then
  export OS="ubuntu"
fi

if [[ "$OS" -eq "osx"  &&  ! $(groups | grep &>/dev/null '\badmin\b') ]]; then
    is_standard_user=true
fi

if [[ $(sudo -u root whoami) != "root" ]]; then
    e_error "Sorry, you need root to run parts of this script exiting."
    # Ask to setup /etc/sudoers
    read -p '''Do you need to setup /etc/sudoers ?
    1. Yes, as runaspw
    2. Yes, as targetpw
    3. No 
    ''' yn
    case $yn in
    [1]* ) 
      read -p "Enter the username to use:" username
      read -p "Enter the group to use:" groupname
      su $username -m -c "echo 'Defaults:%$groupname runas_default=$username, runaspw' | sudo tee -a /etc/sudoers;
      echo '%$groupname ALL=(ALL) ALL' | sudo tee -a /etc/sudoers"
      ;;
    [2]* )
      read -p "Enter the group to use:" groupname
      su -m -c "echo 'Defaults:%$groupname targetpw' >> /etc/sudoers; 
      echo '%$groupname ALL=(ALL) ALL' >> /etc/sudoers"
      ;;
    * ) e_error "Skipping /etc/sudoers setup"
        exit 1 
        ;;
    esac
    if [[ $(sudo -u root whoami) != "root" ]]; then
      e_error "Sorry, you need root to run parts of this script exiting."
      exit 1
    fi
    
fi
    


# Keep-alive: update existing `sudo` time stamp until `.osx` has finished
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

#Ensure command line tools are installed 
if [[ "$OS" = "osx" ]]; then
  xcode-select -p 2&> /dev/null
  rs=$?
  # Ensure that we can actually, like, compile anything.
  # If XCode CLI Tools aren't installed
  # We assume if not CLI tools clean install and update the whole system
  if [[ $rs != 0 ]]; then
    e_header "Installing XCode Command Line Tools and All Updates"
    # create the placeholder file that's checked by CLI updates' .dist code
    # in Apple's SUS catalog
    touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    # install all the updates
    # Find the last listed update in the Software Update feed with "Command Line Tools" in the name
    cmd_line_tools=$(softwareupdate -l | awk '/\*\ Command Line Tools/ { $1=$1;print }' | tail -1 | sed 's/^[[ \t]]*//;s/[[ \t]]*$//;s/*//' | cut -c 2-)
    #Install the command line tools
    softwareupdate -i "$cmd_line_tools" -v
    # Remove the temp file
    if [[ -f "/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress" ]]; then
      rm -rf "/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
    fi
    # Install the rest of the updated
    softwareupdate -iav
    e_header "Must Reboot Damn you Apple"
    # This creates a .profile and will continue the install upon reboot.
    # This works because:
    # a. On a clean install before any mods upon issuing sudo reboot the terminal reopens as part of restore previous state
    # b. One a clean install .profile does not exist so it easy to manipulate and later delete.
    echo 'bash -c "$(curl -fsSL https://raw.github.com/ravivcohen/dotfiles/master/bin/dotfiles)"' >> .profile
    sleep 5
    sudo -u root reboot
  fi
fi

sleep 10
if [[ -e "$HOME/.profile" ]]; then
  e_header "Removing .profile"
  rm -rf "$HOME/.profile"
fi

# Ensure that we can actually, like, compile anything.
if [[ ! "$(type -P gcc)" && "$OS" = "osx" ]]; then
  e_error "The XCode Command Line Tools must be installed first."
fi

# If Git is not installed...
if [[ ! "$(type -P git)" ]]; then
  # OSX
  if [[ "$OS" = "osx" ]]; then
    # Since apple dropped support for 10.6 and 10.7 is next.
    # I assume you already have git installed its default on 10.8 +
    e_error "No GIT ? supported osx 10.8 +"
    exit 1
  # Ubuntu.
  elif [[ "$OS" = "ubuntu" ]]; then
    # Git is fairly easy.
    e_header "Installing Git"
    sudo apt-get -qq install git-core
  fi
fi

# If Git isn't installed by now, something exploded. We gots to quit!
if [[ ! "$(type -P git)" ]]; then
  e_error "Git should be installed. It isn't. Aborting."
  exit 1
fi

## Check if .dotfiles exist
if [[ ! -d ~/.dotfiles ]]; then
  export new_dotfiles_install=1
  # ~/.dotfiles doesn't exist? Clone it!
  e_header "Downloading dotfiles"
  git clone git://github.com/ravivcohen/dotfiles.git ~/.dotfiles
  cd ~/.dotfiles
else
    if [[ -z "$skip_update"  ]]; then
      cd ~/.dotfiles
      # Check if dotfiles dirty
      git update-index -q --refresh
      git diff-index --quiet HEAD
      if [[ $? -eq 0 ]] && [[ -z "$(git ls-files --exclude-standard --others)" ]]; then
        # Update remote info
        git remote update >&-
        # Check if the dotfiles dir is out-of-date
        LOCAL=$(git rev-parse @)
        REMOTE=$(git rev-parse @{u})
      
        if [ $LOCAL = $REMOTE ]; then
            e_header "Dotfiles are up-to-date"
            exit 1
        elif [ $LOCAL = $(git merge-base @ @{u}) ]; then
            e_header "Updating dotfiles"
            git pull
        else
            e_error "Dotfiles out-of-sync"
            git status
            exit 1
        fi

      else
        e_error "Dotfiles are dirty"
        git status
        exit 1
      fi

    fi
fi

# Add binaries into the path
PATH=~/.dotfiles/bin:$PATH
export PATH

# Tweak file globbing.
shopt -s dotglob
shopt -s nullglob


# Create caches directory, if it doesn't already exist.
#mkdir -p "$HOME/.dotfiles/caches"

# If backups are needed, this is where they'll go.
backup_dir="$HOME/.dotfiles/backups/$(date "+%Y_%m_%d-%H_%M_%S")/"
backup=

e_header "Running Init"
do_stuff "init"


# 2. Copy and Link Over Files 
do_stuff "copy"
do_stuff "link"

# Alert if backups were made.
if [[ "$backup" ]]; then
  echo -e "\nBackups were moved to ~/${backup_dir#$HOME/}"
fi

# Lest I forget to do a few additional things...
if [[ "$new_dotfiles_install" && -e "conf/firsttime_reminder.sh" ]]; then
  e_header "First-Time Reminders"
  source "conf/firsttime_reminder.sh"
fi

# All done!
e_header "All done!"
